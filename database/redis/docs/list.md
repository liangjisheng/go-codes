# list

List(列表)类型用于存储一系列有序的字符串元素。每个列表项都是一个字符串，列表本身是按照插入顺序排序的，
这意味着你可以保留元素的插入顺序.

双向链表：Redis内部使用双向链表实现List，这使得在列表的头部或尾部插入和弹出元素都非常高效，时间复杂度为O(1)。
有序性：列表中的元素保持插入时的顺序，可以按照索引位置访问元素。
元素重复：列表允许存储重复的元素。
长度限制：理论上，一个列表可以包含最多2^32 - 1个元素（大约4294967295个）。
多种操作：支持多种操作，包括从两端添加/删除元素（LPUSH/RPUSH, LPOP/RPOP），获取指定范围内的元素
（LRANGE），以及阻塞式弹出（BLPOP/BRPOP）等

lpush命令 将一个或多个值value插入到列表key的表头。如果key不存在，会在插入值之前创建一个空列表。
当多个值被插入时，它们会按照从左到右的顺序入栈

rpush与lpush相似，但它是将一个或多个值value插入到列表key的表尾（右侧）。同样，如果key不存在，则先创建空列表。

lrange返回列表key中指定范围的元素。start和stop是基于0的索引，其中0表示列表的第一个元素，-1表示最后一个元素。
如果stop被省略或设置为-1，则返回从start到列表结束的所有元素

```redis
127.0.0.1:6379> lpush list1 1 2 3 4 5 # 注意遍历时的顺序
(integer) 5
127.0.0.1:6379> lrange list1 0 -1 
1) "5"
2) "4"
3) "3"
4) "2"
5) "1"
127.0.0.1:6379> rpush list2 1 2 3 4 5# 注意遍历时的顺序
(integer) 5
127.0.0.1:6379> lrange list2 0 -1
1) "1"
2) "2"
3) "3"
4) "4"
5) "5"
127.0.0.1:6379>
```

lpop移除并返回列表key中的第一个元素或count个元素,这个操作是从列表的左侧（头部）进行的。
如果key不存在或者列表为空，命令返回nil。
LPOP key [count]

rpop与LPOP类似，但它是移除并返回列表key中的最后一个元素或倒数count个元素，即从列表的右侧（尾部）进行操作。
如果列表不存在或为空，命令也返回nil。
RPOP key [count]

```redis
127.0.0.1:6379> lpop list1 
"5"
127.0.0.1:6379> lpop list1 2
1) "4"
2) "3"
127.0.0.1:6379> lrange list1 0 -1
1) "2"
2) "1"
127.0.0.1:6379> 127.0.0.1:6379> rpop list1 
"1"
127.0.0.1:6379>
```

lindex返回列表key中，指定index位置的元素。
index参数可以通过正数和负数来指定位置：正数表示从列表开头开始计数的位置，负数则表示从列表结尾开始计数的位置
（-1 表示最后一个元素，-2 表示倒数第二个元素，依此类推）

```redis
127.0.0.1:6379> lpush list1 1 2 3 4 5
(integer) 5
127.0.0.1:6379> lindex list1 0
"5"
127.0.0.1:6379> lindex list1 -1
"1"
127.0.0.1:6379>
```

LLEN key 返回列表key的长度。如果key不存在或者不是一个列表，那么命令返回0

```redis
127.0.0.1:6379> lrange list1 0 -1
1) "5"
2) "4"
3) "3"
4) "2"
5) "1"
127.0.0.1:6379> llen list1
(integer) 5
127.0.0.1:6379>
```

LREM key count value 删除 count 个值等于 value 的元素

count参数决定了移除操作的方式：
如果count > 0，则从列表的左边开始，移除最多count个与value相等的元素。
如果count < 0，则从列表的右边开始，移除最多count个与value相等的元素。
如果count = 0，则移除列表中所有与value相等的元素。

```redis
127.0.0.1:6379> lpush list1 1 2 3 4 3 2 1
(integer) 7
127.0.0.1:6379> lrem list1 0 2 
(integer) 2 # 1 3 4 3 1
127.0.0.1:6379> lrem list1 1 3
(integer) 1 # 1 4 3 1
127.0.0.1:6379> lrem list1 -1  1
(integer) 1 # 1 4 3
127.0.0.1:6379> lrange list1 0 -1
1) "1"
2) "4"
3) "3"
127.0.0.1:6379>
```

ltrim 截取列表key，只保留指定范围的元素。
start和stop参数是基于0的索引，其中0是列表的第一个元素，-1是最后一个元素。

```redis
127.0.0.1:6379> lpush list1 1 2 3 4 5
(integer) 5
127.0.0.1:6379> ltrim list1 2 4
OK
127.0.0.1:6379> lrange list1 0 -1
1) "3"
2) "2"
3) "1"
127.0.0.1:6379>
```

rpoplpush 可以原子性地从源列表右侧弹出一个元素，并将该元素插入到目的列表的左侧
RPOPLPUSH [源列表] [目的列表]
注意:这个操作是原子性的，保证了在多客户端环境下操作的完整性，不会因为并发操作而丢失数据

```redis
127.0.0.1:6379> lpush list1 1 2 3 4 5
(integer) 5
127.0.0.1:6379> lpush list2 6 7 8 9 10
(integer) 5
127.0.0.1:6379> rpoplpush list1 list2
"1"
127.0.0.1:6379> lrange list1 0 -1
1) "5"
2) "4"
3) "3"
4) "2"
127.0.0.1:6379> lrange list2 0 -1 
1) "1"
2) "10"
3) "9"
4) "8"
5) "7"
6) "6"
127.0.0.1:6379>
```

lset 设置列表（list）中的 index 位置元素

```redis
127.0.0.1:6379> lpush list1 1 2 3
(integer) 3
127.0.0.1:6379> lset list1 1 string
OK
127.0.0.1:6379> lrange list1 0 -1
1) "3"
2) "string"
3) "1"
127.0.0.1:6379>
```

LINSERT命令用于在一个列表（list）的已存在元素之前或之后插入一个新的元素
linsert key BEFORE|AFTER pivot element

```redis
127.0.0.1:6379> lrange list1 0 -1
1) "3"
2) "string"
3) "1"
127.0.0.1:6379> linsert list1 before string list
(integer) 4
127.0.0.1:6379> linsert list1 after string hash
(integer) 5
127.0.0.1:6379> lrange list1 0 -1
1) "3"
2) "list"
3) "string"
4) "hash"
5) "1"
127.0.0.1:6379>
```
